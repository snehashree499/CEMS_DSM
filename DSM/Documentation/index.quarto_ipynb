{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: Discrete Time Delta Sigma Modulator\n",
        "author:\n",
        "  - name: Hrishikesh Pangavhane\n",
        "    Matriculation number: 5363452\n",
        "    #corresponding: true\n",
        "    email: hrishipangavhane@gmail.com\n",
        "    affiliations:\n",
        "      - Hochschule Bremen\n",
        "  - name: Sneha Shree Katepalli\n",
        "    Matriculation number: 5364673\n",
        "    #corresponding: true\n",
        "    email: snehashree499@gmail.com\n",
        "    affiliations:\n",
        "      - Hochschule Bremen\n",
        "  - name: Hanieh Alteidar\n",
        "    Matriculation number: 5363618\n",
        "    #corresponding: true\n",
        "    email: hanieh.alaei7596@gmail.com\n",
        "    affiliations:\n",
        "      - Hochschule Bremen\n",
        "date: last-modified\n",
        "bibliography: references.bib\n",
        "citation:\n",
        "  url: https://github.com/snehashree499/CEMS_DSM\n",
        "\n",
        "---\n",
        "\n",
        "\\newcommand{\\VDD}[1][]{V_\\mathrm{DD#1}}\n",
        "\\newcommand{\\VSS}[1][]{V_\\mathrm{SS#1}}\n",
        "\\newcommand{\\VGS}[1][]{V_\\mathrm{GS#1}}\n",
        "\\newcommand{\\Vgs}[1][]{V_\\mathrm{gs#1}}\n",
        "\\newcommand{\\VDS}[1][]{V_\\mathrm{DS#1}}\n",
        "\\newcommand{\\Vds}[1][]{V_\\mathrm{ds#1}}\n",
        "\\newcommand{\\VSB}[1][]{V_\\mathrm{SB#1}}\n",
        "\\newcommand{\\Vsb}[1][]{V_\\mathrm{sb#1}}\n",
        "\\newcommand{\\VGB}[1][]{V_\\mathrm{GB#1}}\n",
        "\\newcommand{\\vgs}[1][]{v_\\mathrm{gs#1}}\n",
        "\\newcommand{\\vds}[1][]{v_\\mathrm{ds#1}}\n",
        "\\newcommand{\\Vth}[1][]{V_\\mathrm{th#1}}\n",
        "\\newcommand{\\gm}[1][]{g_\\mathrm{m#1}}\n",
        "\\newcommand{\\gmb}[1][]{g_\\mathrm{mb#1}}\n",
        "\\newcommand{\\gmid}{g_\\mathrm{m}/I_\\mathrm{D}}\n",
        "\\newcommand{\\gds}[1][]{g_\\mathrm{ds#1}}\n",
        "\\newcommand{\\CGG}[1][]{C_\\mathrm{GG#1}}\n",
        "\\newcommand{\\Cgg}[1][]{C_\\mathrm{gg#1}}\n",
        "\\newcommand{\\CGS}[1][]{C_\\mathrm{GS#1}}\n",
        "\\newcommand{\\Cgs}[1][]{C_\\mathrm{gs#1}}\n",
        "\\newcommand{\\CGB}[1][]{C_\\mathrm{GB#1}}\n",
        "\\newcommand{\\Cgb}[1][]{C_\\mathrm{gb#1}}\n",
        "\\newcommand{\\CGD}[1][]{C_\\mathrm{GD#1}}\n",
        "\\newcommand{\\Cgd}[1][]{C_\\mathrm{gd#1}}\n",
        "\\newcommand{\\CDG}[1][]{C_\\mathrm{DG#1}}\n",
        "\\newcommand{\\Cdg}[1][]{C_\\mathrm{gd#1}}\n",
        "\\newcommand{\\CDB}[1][]{C_\\mathrm{DB#1}}\n",
        "\\newcommand{\\Cdb}[1][]{C_\\mathrm{db#1}}\n",
        "\\newcommand{\\CSB}[1][]{C_\\mathrm{SB#1}}\n",
        "\\newcommand{\\Csb}[1][]{C_\\mathrm{sb#1}}\n",
        "\\newcommand{\\ID}[1][]{I_\\mathrm{D#1}}\n",
        "\\newcommand{\\Id}[1][]{I_\\mathrm{d#1}}\n",
        "\\newcommand{\\id}[1][]{i_\\mathrm{d#1}}\n",
        "\\newcommand{\\fco}{f_\\mathrm{co}}\n",
        "\\newcommand{\\VBE}[1][]{V_\\mathrm{BE#1}}\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "# Block Level Representation{#Block-Level}\n",
        "\n",
        "\n",
        "![Block Diagram](figures/_fig_Block_Diagram.png){#fig-Block-Diagram}\n",
        "\n",
        "@fig-Block-Diagram shows that we need discrete time integrators for our loop filter, 1-bit quantizer and 1-bit feedback. Before diving deep into the circuit level, let's look at our target specifications.\n",
        "\n",
        "| Parameter           | Symbol | Value | Units |\n",
        "|---------------------|--------|-------|-------|\n",
        "| Bandwidth           | $f_B$ | 1     | kHz   |\n",
        "| Sampling frequency  | $f_{s}$ | 1     | MHz   |\n",
        "| Signal-to-Noise Ratio | $SNR$    | 100   | dB    |\n",
        "| Supply voltage      | $V_{dd}$ | 1.5   | V     |\n",
        "\n",
        ": **Table 1: Specifications.** {#tb-specifications}\n",
        "\n",
        "\n",
        "\n",
        "## NTF Selection{#sec-NTF}\n",
        "\n",
        "![Block Diagram](figures/_fig_NTF.qmd){#fig-NTF}\n",
        "\n",
        "The matlab [code fragment](https://github.com/snehashree499/CEMS_DSM/blob/main/DSM/Matlab/Second_Order_SwitchCap.m)  creates an NTF and evaluates\n",
        "its performance using an SQNR versus amplitude curve (see @fig-NTF)). Since the ideal peak\n",
        "SQNR is 120 dB, quantization noise is 20 dB below our target noise level. This margin is\n",
        "at the generous end of the 10–20 dB range that typically separates the ideal SQNR from\n",
        "the target SNR.\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "# Block Level Representation{#Block-Level}\n",
        "\n",
        "\n",
        "![Block Diagram](figures/_fig_Block_Diagram.png){#fig-Block-Diagram}\n",
        "\n",
        "@fig-Block-Diagram shows that we need discrete time integrators for our loop filter, 1-bit quantizer and 1-bit feedback. Before diving deep into the circuit level, let's look at our target specifications.\n",
        "\n",
        "| Parameter           | Symbol | Value | Units |\n",
        "|---------------------|--------|-------|-------|\n",
        "| Bandwidth           | $f_B$ | 1     | kHz   |\n",
        "| Sampling frequency  | $f_{s}$ | 1     | MHz   |\n",
        "| Signal-to-Noise Ratio | $SNR$    | 100   | dB    |\n",
        "| Supply voltage      | $V_{dd}$ | 1.5   | V     |\n",
        "\n",
        ": **Table 1: Specifications.** {#tb-specifications}\n",
        "\n",
        "\n",
        "\n",
        "## NTF Selection{#sec-NTF}\n",
        "\n",
        "![Block Diagram](figures/_fig_NTF.qmd){#fig-NTF}\n",
        "\n",
        "The matlab [code fragment](https://github.com/snehashree499/CEMS_DSM/blob/main/DSM/Matlab/Second_Order_SwitchCap.m)  creates an NTF and evaluates\n",
        "its performance using an SQNR versus amplitude curve (see @fig-NTF)). Since the ideal peak\n",
        "SQNR is 120 dB, quantization noise is 20 dB below our target noise level. This margin is\n",
        "at the generous end of the 10–20 dB range that typically separates the ideal SQNR from\n",
        "the target SNR.\n",
        "\n",
        "\n",
        "# Realisation of discrete time second order switch capacitor circuit {#sec-SwitchCap}\n",
        "\n",
        "\n",
        "# OTA design for Switch Capacitor integrators {#sec-OTA}\n",
        "\n",
        "As we now enter on IC design level, we need to implement the discrete time integrator using CMOS elements. We will use [Xschem](https://xschem.sourceforge.io) for schematic entry and [ngspice](https://ngspice.sourceforge.io) for simulation. The 130nm CMOS technology **IHP-SG13G2** from [IHP Microelectronics](https://www.ihp-microelectronics.com). Tools and PDK are integrated in the [IIC-OSIC-TOOLS](https://github.com/iic-jku/IIC-OSIC-TOOLS) Docker image. This PDK is open-source, and the complete process specification can be found at [SG13G2 process specification](https://github.com/IHP-GmbH/IHP-Open-PDK/blob/main/ihp-sg13g2/libs.doc/doc/SG13G2_os_process_spec.pdf)\n",
        "\n",
        "## Deriving required parameters for design\n",
        "\n",
        "As mention in @sec-SwitchCap the load driven by our circuit is purely capacitive and hence taking consideration of swing over gain, **Folded Cascode** topology (see @fig-OTA) is what best suited in our case, where we have PMOS input pair.\n",
        "\n",
        "\n",
        "![Candidate OTA](figures/_fig_OTA.qmd){#fig-OTA}\n",
        "\n",
        "\n",
        "Detailed analysis of **Folded Cascode** topology can be accessed [here](https://github.com/pangavhanehreeshi/SecondOrder_SingleBit_DSM/blob/main/DSM/Designs_Hrishi/RealCircuits/Folded%20Cascode/FoldedCascode%20_Theory.pdf). You can find the **quantitative** as well as **qualitative** analysis , **noise analysis**, **offset / mismatch analysis**.\n",
        "\n",
        "![OTA Slew Currents](./figures/_fig_OTA_SlewCurrents.png){#fig-OTA-SlewCurrents}\n",
        "\n",
        "\n",
        "### Deriving $I$\n",
        "As shown in @fig-OTA-SlewCurrents the magnitude of the output\n",
        "current under these conditions is $I$, where $I$ is the bias current in each half of the differential\n",
        "pair. ($I$ is also assumed to be the standing current in the output cascodes.) Clearly, $I$\n",
        "must be large enough to transfer the charge from the input capacitor(s) to the integrating\n",
        "capacitor in the allotted time.[@Understanding_Delta-Sigma_Data_Converters] \n",
        "\n",
        "Let’s allocate half of a clock phase (i.e., one quarter of a\n",
        "clock period) for slewing. Since the voltage on the left side of the input capacitor C1 can change by as much as ${{V_\\mathrm{DD}}} = 1.5 V$ , we therefore need \n",
        "\n",
        "$$\n",
        "I > \\frac{C_1 VDD}{T/4} = \\frac{0.4 \\, \\mathrm{pF} \\cdot 1.5 \\, \\mathrm{V}}{0.25 \\, \\mu\\mathrm{s}} = 3 \\, \\mu\\mathrm{A}.\n",
        "$$\n",
        "\n",
        "### Deriving ${g_\\mathrm{m}}$ from Time-constant calculation\n",
        "\n",
        "![Time Constant Calculation](figures/_fig_RC_Calculation.png){#fig-RC-Calculations}\n",
        "\n",
        "@fig-RC-Calculations shows the small-signal model of an integrator in the charge-transfer\n",
        "phase and an equivalent circuit from which we see that the time-constant is $$\n",
        "\\tau = RC = \\frac{C_1 + C_3 + \\frac{C_1 C_3}{C_2}}{g_\\mathrm{m}}\n",
        "$$\n",
        "\n",
        " \n",
        "Now let's say we take the linera settling to provide attenuation of 100dB\n",
        "\n",
        "$$\n",
        "\\frac{T}{4} = \\tau \\ln(10^5) \\approx 12\\tau\n",
        "$$\n",
        "\n",
        "This gives us \n",
        "$$\n",
        "{g_\\mathrm{m}} = \\frac{C_1 + C_3 + \\frac{C_1 C_3}{C_2}}{\\frac{T}{48}} = 21.9 \\, \\mu\\frac{A}{V}\n",
        "$$\n",
        "\n",
        "### Deciding $L$ and $W$ for MOSFETS \n",
        "\n",
        "Now that we have the exact values for ${g_\\mathrm{m}}$ and ${I_\\mathrm{D}}$, we can derive the values of $L$ and $W$ by making use of ${g_\\mathrm{m}}$_${I_\\mathrm{D}}$ vs ${I_\\mathrm{D}}$_$W$ curve.\n",
        " Refer to @sec-gmid-method for detailed discussion regarding sizing.\n",
        "\n",
        "\n",
        "We already know the current flowing throught each MOSFET (See @fig-OTA-SlewCurrents). As shown in @fig-gm_IdvsId_W-nmos and @fig-gm_IdvsId_W-pmos, by appropriately choosing the $L$, we can obtain $W$ for \n",
        "\n",
        "\n",
        "$$\n",
        "\\frac{g_m}{I_D} = 7.9\n",
        "\n",
        "$$\n",
        "\n",
        "::: {.callout-note title=\"Important\"}\n",
        "The minimum length consideration while designing in low voltage CMOS technology should be atleast **3 to 4 times** the $L_\\min$. In our case $L_\\min = 0.13 \\, \\mu$.\n",
        ":::\n",
        "\n",
        "\n",
        "![${g_\\mathrm{m}}$_${I_\\mathrm{D}}$ vs ${I_\\mathrm{D}}$_$W$ curve for nmos](figures/_fig_gmid_vs_idw_nmos.svg){#fig-gm_IdvsId_W-nmos}\n",
        "\n",
        "![${g_\\mathrm{m}}$_${I_\\mathrm{D}}$ vs ${I_\\mathrm{D}}$_$W$ curve for pmos](figures/_fig_gmid_vs_idw_pmos.svg){#fig-gm_IdvsId_W-pmos}\n",
        "\n",
        "### OTA biasing using **current mirror**\n",
        "\n",
        "![OTA Biasing](figures/_fig_OTA_Biasing.qmd){#fig-OTA-Biasing}\n",
        "\n",
        "@fig-OTA-Biasing explains the biasing of the OTA using **Wilson's current mirror** topology. \n",
        "\n",
        "### Performance of designed OTA {#sec-Performance-OTA}\n",
        "\n",
        "For understanding how the designed OTA is performing, we run transient analysis, ac analysis and dc analysis. In order to achieve these analysis, we need to put our OTA in negative feedback loop (unity feedback loop in our case) and realize the plots. @fig-OTA-tran shows the transient plot and gives us the time constant in which it reaches the steady state. NgSpice yeilds tsettle = 8.663771e-09\n",
        "\n",
        "\n",
        "@fig-OTA-ac-mag and @fig-OTA-ac-phase shows us the magnitude and phase over a range of frequency.Where NgSpice yeilds dc_gain = 9.156547e-01\n",
        "fbw = 7.544229e+07\n",
        "Gain_error = -8.41453e-02 \n",
        "\n",
        "\n",
        "\n",
        "![Transient Analysis](figures/_fig_OTA_tran.svg){#fig-OTA-tran}\n",
        "\n",
        "\n",
        "![AC Analysis](figures/_fig_OTA_ac_phase.svg){#fig-OTA-ac-phase}\n",
        "\n",
        "\n",
        "![AC Analysis](figures/_fig_OTA_ac_mag.svg){#fig-OTA-ac-mag}\n",
        "\n",
        "\n",
        "# Sizing using gm over Id method{#sec-gmid-method}\n",
        "\n",
        "Now that we have designed the topology of our OTA(refer to foldedCascode) and \n",
        "we already know the value of $g_\\mathrm{m}$, and $I_\\mathrm{D}$, we need to derive the widths $W$ $L$ and lengths of our design. \n",
        "\n",
        "Often, transistor sizing in entry-level courses is based on the square-law model, where a simple analytical equation for the drain current can be derived. However, in nanometer CMOS, the MOSFET behavior is much more complex than these simple models. Also, this highly simplified derivations introduce concepts like the threshold voltage or the overdrive voltage, which are interesting from a theoretical viewpoint, but bear little practical use. Also this model is only valid in strong inversion. As soon as the gate-source voltage gets smaller, the square-law model breaks, as the drain current component based on diffusion currents gets dominant. Modern compact MOSFET models (like the PSP model used in SG13G2) use hundreds of parameters and fairly complex equations to somewhat properly describe MOSFET behavior over a wide range of parameters like width, length and temperature. A modern approach to MOSFET sizing is thus based on the thought to use exactly these MOSFET models, characterize them, put the resulting data into tables and charts, and thus learn about the complex MOSFET behavior and use it for MOSFET sizing.\n",
        "\n",
        "The gm over Id methodology has the huge advantage that it catches MOSFET behavior quite accurately over a wide range of operating conditions, and the curves look very similar for pretty much all CMOS technologies, from micrometer bulk CMOS down to nanometer FinFET devices. Of course the absolute values change, but the method applies universally.\n",
        "\n",
        "A brief is available [here](https://github.com/iic-jku/analog-circuit-design/blob/main/sizing/Ref_Murmann_gmID.pdf)\n",
        "\n",
        "##Testbench for MOSFETSWEEP{#sec-techsweep-testbench}\n",
        "\n",
        "In order to get all the operating points for lv nmos shown in @fig-techsweep-nmos-tb, and lv pmos shown in @fig-techsweep-pmos-tb, we run a techsweep and obtain curves related to parameters such as ${g_\\mathrm{m}}$, ${g_\\mathrm{ds}}$, ${C_\\mathrm{gs}}$, ${I_\\mathrm{d}}$, ${V_\\mathrm{GS}}$, ${V_\\mathrm{DS}}$, $L$, $W$. We create a testbench in Xschem which sweeps the terminal voltages, and records various large- and small-signal parameters, which are then stored in large tables.\n",
        "\n",
        "![Testbench for LV NMOS $\\gmid$ characterization.](figures/tb_sg13_lv_nmos.svg){#fig-techsweep-nmos-tb}\n",
        "\n",
        "![Testbench for LV PMOS $\\gmid$ characterization.](figures/tb_sg13_lv_pmos.svg){#fig-techsweep-pmos-tb}\n",
        "\n",
        "\n",
        "After obtaining the parameters we plot them using Matlab, and obtain some important curves or graphs in order to understand the MOSFET's behaviour.\n",
        "\n",
        "\n",
        "# 1-Bit Quantiser\n",
        "// Add info @Hreeshi\n",
        "\n",
        "## Designing the 1-Bit Quantiser\n",
        "Based on the collected experience in this lecture we are desiging a 1-bit Quantiser (Comparator) in Xschem. \n",
        "Below is the prepared comparator design which will be discused in detail next.\n",
        "\n",
        "//Add the circuit diagram\n",
        "\n",
        "\n",
        "![Schematic for Strong arm latch.](/figures/Comparator.svg){#fig-techsweep-nmos-tb}\n",
        "\n",
        "\n",
        "# Clock Generator \n",
        "\n",
        "Mixed-signal systems must balance elements that are critical in the digital domain as well as the analog domain. One important area of digital interface design in mixed-signal systems is clocking, which must be used to enforce timing between components and to read data from ADCs. Many mixed-signal systems operating in the low-to-moderate frequency range will use a reference oscillator, and there may be a need to synchronize multiple clocks across a system to accurately sample and synchronize the entire system. In designing a sigma- delta ADC, we can say that the clock is the heartbeat of the ADC, synchronizing all operations. It means that the clock plays a crucial role in the overall system operation. The clock precisely controls the timing of various ADC components, and without it, neither sampling nor processing can occur.\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "let's see clock's role precisely:\n",
        "1. Sampling Control\n",
        "The clock determines when the ADC should take a sample of the analog signal. In your system, the sampling frequency is 1 MHZ, meaning a new sample is taken every 1000 microseconds. \n",
        "\n",
        "\n",
        "$$\n",
        "T_s = \\frac{1}{f_s} = \\frac{1}{220} = 4.545 s \\, \n",
        "$$\n",
        "\n",
        "If the clock is too slow, insufficient data is captured, leading to signal degradation. If the clock is too fast, the circuit may not respond correctly, introducing noise and errors.\n",
        "2. Control of the ΔΣ (Delta-Sigma) Modulator Processing\n",
        "The Delta-Sigma ADC operates using a feedback loop, which consists of:\n",
        "• Integrators\n",
        "• Comparator\n",
        "• Flip-Flop\n",
        " The clock synchronizes these components, ensuring the correct generation of the digital output. Every clock cycle, the following steps occur:\n",
        "integrator updates its value.\n",
        "• The integrator accumulates past values and combines them with the new input.\n",
        "• This operation occurs once per clock cycle.\n",
        "Comparator determines if the new value is above or below zero.\n",
        "• The comparator outputs a digital 0 or 1 at each clock edge.\n",
        "• This output is directly sent to the digital processing stage.\n",
        "Feedback loop adjusts the input based on the digital output.\n",
        "• The feedback system returns a digital signal to the integrator to correct conversion errors.\n",
        "If the clock is not properly configured, the modulator may malfunction, leading to incorrect digital output.\n",
        "If the clock is too fast, noise increases, and synchronization between analog and digital circuits is lost.\n",
        "3. Flip-Flop Control and Comparator Decision-Making\n",
        "The comparator evaluates the integrator’s output and determines a digital 0 or 1 at each clock edge.\n",
        "Every time the clock triggers, a new digital value is stored, preparing it for further processing.\n",
        "The D Flip-Flop stores this digital value and generates the final bitstream.\n",
        "Without clock flip-flops store the data randomly and that is not the thing we want, because it leads to corrupt digital output.\n",
        "4. Digital Filter (Decimation Filter) Control\n",
        "After the modulator, a digital filter (Decimation Filter) processes the high-speed output data.\n",
        "This filter, operating with the system clock and its divided versions, reduces the data rate to generate the final 16-bit digital output.\n",
        "To design this clock, we must consider that in switch capacitor circuits, the maintenance you should ensure is that the clocks never overlap. This circuits operation is based on charge transfer by switching. As shown by the time-domain waveforms in figure, during integrating phase ∅2, the charge stored in a sampling capacitor Cs is transferred to an integrating capacitor C1 through the ON resistance (Ron) of the switch. The discharging of Cs takes place at an exponentially decaying rate.\n",
        "```{latex}\n",
        "\n",
        "\\documentclass{article}\n",
        "\\usepackage[utf8]{inputenc}\n",
        "\\usepackage{circuitikz}\n",
        "\\pagestyle{empty}\n",
        "\n",
        "\\begin{document}\n",
        "\n",
        "\\begin{tikzpicture}\n",
        "\n",
        "\t% Paths, nodes and wires:\n",
        "\t\\draw node[ieeestd not port] at (4.818, 4.667) {};\n",
        "\t\\draw node[ieeestd not port] at (7.333, 4.667) {};\n",
        "\t\\draw node[ieeestd not port] at (7.725, 4.667) {};\n",
        "\t\\draw node[ieeestd not port] at (8.333, 4.667) {};\n",
        "\t\\draw node[ieeestd not port] at (10.877, 4.667) {};\n",
        "\t\\draw (5.667, 4.667) -- (6.456, 4.667) -- (7.24, 4.667) -- (10, 4.667);\n",
        "\t\\draw (3, 4.667) -- (3.941, 4.667);\n",
        "\t\\draw (11.754, 4.667) -- (13, 4.667);\n",
        "\t\\draw (9.667, 4.667) -| (9.667, 3.333);\n",
        "\t\\draw (6, 4.667) -| (6, 3.333);\n",
        "\t\\draw (3, 6) -| (3, 6.667) -- (3, 6.667) -- (3, 6.667) -- (3.667, 6.667) -| (3.667, 6) -- (4.333, 6) -| (4.333, 6.667) -- (5, 6.667) -| (5, 6) -- (5.667, 6) -| (5.667, 6.667);\n",
        "\t\\draw (3.941, 4.667) |- (4, 5.667) -| (14, 3);\n",
        "\t\\draw (13, 4.667) -- (13, 3);\n",
        "\\end{tikzpicture}\n",
        "\n",
        "\\end{document}\n",
        "```\n",
        "\n",
        "\n",
        "\n",
        "Reasons:\n",
        "\n",
        "\n",
        "1. Preventing short circuit current\n",
        "In switched-capacitor circuits, two switches are controlled by complementary clock phases.\n",
        "\t•\tIf both clock signals go high simultaneously, both switches turn on, creating a short circuit to ground or supply voltage.\n",
        "\t•\tA non-overlapping clock eliminates this issue by ensuring a small delay (Dead Time) between the two clock phases.\n",
        "\n",
        "2. Improving Sampling Accuracy\n",
        "\t•\tIn delta-sigma ADCs, capacitors require sufficient time to charge or discharge before the clock phase changes.\n",
        "\t•\tIf the clock phases overlap, the capacitor may not fully charge, leading to sampling errors.\n",
        "\t•\tA non-overlapping clock ensures accurate data transfer and minimizes noise.\n",
        "\n",
        "3. Reducing Charge Injection & Clock Feedthrough\n",
        "\t•\tOverlapping clock phases can cause charge injections and clock feedthrough, leading to signal distortion and increased noise.\n",
        "\t•\tA non-overlapping clock helps to reduce these effects significantly.\n",
        "\n",
        "How to Generate a Non-Overlapping Clock?\n",
        "To generate ϕ1 and ϕ2 clock phases that never overlap, delay elements (RC delay, buffers, inverters) and NAND/AND gates are commonly used.\n"
      ],
      "id": "8b988f8c"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}